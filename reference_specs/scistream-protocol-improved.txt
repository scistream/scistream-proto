Network Working Group                                           F. Castro
Internet-Draft                                               SciStream Team
Intended status: Informational                              April 15, 2025
Expires: October 17, 2025


        SciStream: Protocol Specification for Data Streaming Between Facilities
                          draft-scistream-protocol-02

Abstract

   The SciStream Protocol allows a third-party client to control how incoming
   packets are forwarded by a Network gateway such as simple firewall
   or load-balancer. Additionally it provides a mechanism for
   data plane security via the use of ephemeral credentials per session.

   Scistream enables a zero-trust end-to-end secure data streaming session
   management between a data producer and consumer in separated untrusted
   facilities. This protocol is designed for scientific facilities
   with strict security requirements to enable integrated research
   initiatives such as real-time data analysis and experimental steering
   when processing requirements exceed their local capacity.

Table of Contents

   1. Introduction ....................................................4
      1.1. Motivation.................................................4
      1.2. Problem Statement..........................................5
      1.3. SciStream Solution.........................................5
   2. Terminology ....................................................6
   3. Protocol Overview ..............................................9
      3.1. Architecture Components ...................................9
         3.1.1. SciStream User Client (S2UC) .........................9
         3.1.2. SciStream Control Server (S2CS) ......................10
         3.1.3. SciStream Data Server (S2DS) .........................11
         3.1.4. Application Controllers ..............................11
      3.2. Protocol Flow ............................................13
         3.2.1. Request Submission ..................................14
         3.2.2. Hello Message Exchange ..............................14
         3.2.3. Tunnel Setup ........................................15
         3.2.4. Data Streaming ......................................16
         3.2.5. Request Release .....................................16
   4. Protocol Messages .............................................18
      4.1. Message Definitions ......................................18
      4.2. Service Definition .......................................21
      4.3. Protocol Buffer Schema ...................................21
   5. Security Framework ............................................22
      5.1. Security Model ...........................................22
      5.2. Authentication Mechanisms ................................23
         5.2.1. Control Channel Authentication ......................23
         5.2.2. Data Channel Authentication .........................24
         5.2.3. Globus Auth Integration ............................25
      5.3. Protection Mechanisms ....................................25
         5.3.1. Data Integrity Protection ...........................25
      5.4. Cross-Domain Security ....................................27
   6. Performance Considerations ....................................28
      6.1. Parallel Streaming Channels ..............................28
   7. Implementation Considerations .................................30
      7.1. Implementation Flexibility ...............................30
      7.2. Extensibility ............................................31
      7.3. Interoperability ........................................31
         7.3.1. Streaming Library Compatibility .....................31
   8. Error Codes and Status Messages ...............................34
  9. Security Considerations ......................................36
  10. References ...................................................37
      10.1. Normative References ....................................37
      10.2. Informative References ..................................37
  Appendix A. Protocol State Machines ..............................38
  Appendix B. Implementation Examples ..............................41
  Appendix C. Acknowledgements .....................................42


1. Introduction

   This document defines the SciStream Protocol, enabling secure data streaming
   between scientific facilities by allowing third-party clients
   to control data flow forwarding and data channel security by use of ephemeral
   credentials per session.

   SciStream is designed to be implemented in the context of computing facilities
   APIs that require secure streaming and service registration as well as
   instrument facilities that need to communicate with these computing facilities.
   Zero-trust architecture security paradigms have been used to implement security
   mechanisms in both control and data channels.

   This document specifies the components, messages, and procedures
   involved in the SciStream Protocol, focusing on the control plane
   behavior and data plane security specifications.

   SciStream shares some high level similarities with the Port Control Protocol (PCP [RFC6887]).
   However PCP lacks in security aspects, PCP relies primarily on source address
   validation which is vulnerable to spoofing and replay attacks.
   It was also not designed for Cross-domain support and is vulnerable to
   eavesdropping of its control messages. FTP security extensions [RFC2228]
   addresses control channel vulnerabilities but it's vulnerable to data channel
   hijacking, such vulnerability is addressed later on by GridFTP and this
   data plane robustness heavily inspired our mechanisms.

1.1. Motivation

   Scientific instrument facilities generate data at ever increasing rates.
   Use cases such as real-time data analysis and experimental steering
   often require data to be processed at remote computing facilities due to local
   computational limitations.

   Traditional file-based transfer methods introduce
   unacceptable latencies for real-time analysis, as they require writing to disk
   at the source, transferring the file, and reading from disk at the destination.
   This imposes bottlenecks on the producer rates as well as consumer rates.

1.2. Problem Statement

   Scientific facilities face several challenges when attempting to establish
   data streaming connections across institutional boundaries:

   1. Security restrictions often prevent direct connections between facilities
   2. Traditional solutions lack the necessary security mechanisms for cross-domain streaming
   3. Data sensitivity requires robust authentication, integrity, and confidentiality
   4. Authorization and access control must be enforceable across domains

   Furthermore, many scientific applications require real-time data processing
   capabilities that cannot be achieved with traditional file-based approaches.

1.3. SciStream Solution

   SciStream addresses these challenges through:

   1. A layered architecture with clear separation between control and data planes
   2. Strong authentication mechanisms using OAUTH2.0 and PSK-TLS
   3. Configurable security levels to balance performance and protection
   4. Support for parallel data channels to maximize throughput

   The protocol's architecture is illustrated in Figure 1:

   +-----------------+           +------------------+          +-----------------+
   |                 |           |                  |          |                 |
   | Data Producer   |           | SciStream Data   |          | Data Consumer   |
   | Application     |<--------->| Server (S2DS)    |<-------->| Application     |
   |                 |  (Secure) |                  |  (Secure)|                 |
   +-----------------+           +------------------+          +-----------------+
                                         ^
                                         |
                                         v
                                 +------------------+
                                 |                  |
                                 | SciStream Control|
                                 | Server (S2CS)    |
                                 |                  |
                                 +------------------+
                                         ^
                                         |
                                         v
                                 +------------------+
                                 |                  |
                                 | SciStream User   |
                                 | Client (S2UC)    |
                                 |                  |
                                 +------------------+

                           Figure 1: SciStream Architecture

   This architecture enables secure, high-performance data streaming between
   facilities while maintaining the separation of control and data planes
   necessary for robust security.

2. Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in BCP 14
   [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as
   shown here.

   This document uses the following terms:

   Facility
      A network security domain such as scientific instrument facility or
      computing center where SciStream components are deployed.

   SciStream Control Server (S2CS)
      Service running at each facility that manages local resources. It exposes the
      SciStream Control API. It supports user authentication via OAUTH2.0.
      Responds to REQUEST, HELLO, UPDATE messages.

   SciStream Data Server (S2DS)
      Component that implements the data plane behavior of SciStream.
      Currently tightly coupled with SciStream Control Server. (Could be another API)
      Current reference implementation works as a proxy but this is not strict.

   SciStream User Client (S2UC)
      Software component responsible for communicating with SciStream Control servers.
      Client works as a third-party authorizer of the data channel streams composed
      by the producer and consumer apps. The client is the consumer of the SciStream API.
      It's responsible for user authentication before the request message.

   Data Producer Application
      A host behind the SciStream data server. This is the host that will receive
      inbound traffic resulting from a SciStream request.
      This host listens for a TCP SYN when using TCP.

   Data Consumer Application
      A host behind the SciStream data server. This is the host that initiates the outbound connection.

   Application Controller
      Software component that interfaces between applications and the SciStream
      infrastructure. May be embedded in applications or operate as a separate
      service.

   UID
      Unique identifier for a specific request. Used as a shared secret for
      authentication and session identification.

   Inbound Receiver
      SciStream data server receiving inbound traffic to be forwarded to the data producer.
      Inbound proxy only accepts authenticated connections via TLS1.2
      and PSK implementation using UID. It then forwards data to the producer.

   Outbound Sender
      SciStream data server sending outbound traffic to the inbound receiver
      so it can then be forwarded to the data producer.
      Outbound proxy establishes a TLS tunnel with the Inbound proxy using the
      UID as a PSK.

   Internal Application Address
      The internal IP address of a Data producer or Data Consumer that will communicate
      with SciStream.

   External Application Address
      The external IP-port tuple referent to a specific application.
      External address is generally public routable.

   Remote Peer Address
      Address of a remote peer as seen by the internal host.

   Mapping, Port Mapping
      Similar to NAT, SciStream creates map between tuple of (internal IP address, port)
      to a (external ip address, port) tuple. The underlying behavior of SciStream could vary.
      It could work as a NAT, firewall or loadbalancer.
      Specifically, the current reference implementation terminates
      the connection in case of TCP it then encapsulates the payload into a
      new connection using TLS.

   Control Channel
      The communication path used for exchanging control messages between
      SciStream components, primarily for authentication, authorization,
      and session management.

   Data Channel
      The communication path used for transferring the actual data streams
      between facilities.

   Session
      A logical connection between a data producer and consumer, authorized
      and managed by the SciStream infrastructure.

3. Protocol Overview

   The SciStream protocol defines a set of interactions between components
   to establish and maintain secure data streaming sessions between facilities.
   This section provides an overview of the protocol's components, deployment
   models, and flow of operations.

3.1. Architecture Components

   The SciStream architecture consists of several key components that interact
   to provide secure data streaming capabilities. Figure 2 illustrates the
   relationship between these components:

   +-----------------+                                      +-----------------+
   | Producer        |                                      | Consumer        |
   | Facility        |                                      | Facility        |
   |                 |                                      |                 |
   | +-------------+ |                                      | +-------------+ |
   | | Data Prod.  | |                                      | | Data Cons.  | |
   | | Application | |                                      | | Application | |
   | +------^------+ |                                      | +------^------+ |
   |        |        |                                      |        |        |
   | +------v------+ |                                      | +------v------+ |
   | | S2DS        | |<------------------------------------>| | S2DS        | |
   | +-------------+ |                                      | +-------------+ |
   |        ^        |                                      |        ^        |
   |        |        |                                      |        |        |
   | +------v------+ |         +------------------+         | +------v------+ |
   | | S2CS        | |<------->|      S2UC        |<------->| | S2CS        | |
   | +-------------+ |         +------------------+         | +-------------+ |
   |                 |                                      |                 |
   +-----------------+                                      +-----------------+

                    Figure 2: SciStream Component Interaction

3.1.1. SciStream User Client (S2UC)

   The SciStream User Client (S2UC) allows agents to interact with the SciStream
   infrastructure by performing the following functions:

   - Authenticates users to the S2CS using OAUTH2.0
   - Generates and submits REQUEST messages to authorize data streaming
   - Manages the lifecycle of streaming sessions
   - Receives responses from S2CS and updates applications as needed

   The S2UC MUST authenticate the OAUTH2.0 token provider before submitting any requests
   and MUST maintain secure communication with the S2CS throughout the
   session lifecycle.

   Figure 3 illustrates the S2UC state machine:

   +-------------+         +-------------+         +-------------+
   |             |         |             |         |             |
   | Unauthenti- |         |Authenticated|         | Request     |
   | cated       |-------->|             |-------->| Submitted   |
   |             |         |             |         |             |
   +-------------+         +-------------+         +-------------+
                                 |                        |
                                 v                        v
                           +-------------+         +-------------+
                           |             |         |             |
                           | Request     |<------->| Active      |
                           | Error       |         | Streaming   |
                           |             |         |             |
                           +-------------+         +-------------+
                                                         |
                                                         v
                                                   +-------------+
                                                   |             |
                                                   | Stream      |
                                                   | Released    |
                                                   |             |
                                                   +-------------+

                      Figure 3: S2UC State Machine

3.1.2. SciStream Control Server (S2CS)

   The SciStream Control Server (S2CS) is the central component responsible
   for managing authentication, authorization, and resource allocation within
   a facility. The S2CS performs the following functions:

   - Authenticates S2UC requests using OAUTH2.0
   - Validates resource availability and permissions
   - Coordinates with S2DS for data streaming setup
   - Manages the lifecycle of streaming sessions
   - Maintains a registry of active sessions and their properties
   - Enforces security policies for the facility

   The S2CS MUST verify the identity and authorization of all requests
   before approving any resource allocation or streaming session. It
   SHOULD implement rate limiting and resource quotas to prevent abuse.

   S2CS instances at different facilities MAY communicate with each other
   to coordinate cross-domain streaming sessions, although the standard
   model involves user-mediated coordination.

3.1.3. SciStream Data Server (S2DS)

   The SciStream Data Server (S2DS) functions as gateway between the internal
   network and the external WAN. It is responsible for the actual data movement
   between facilities. The S2DS performs the following functions:

   - Forwards data from producers to consumers
   - Manages network connections and bandwidth
   - Provides data buffering if needed
   - Reports status to the S2CS (SHOULD)
   - Implements security protections for data streams (MAY)
   - Supports parallel streams for performance scaling (SHOULD)

   Multiple implementations of S2DS are supported, including a custom
   SciStream implementation and commercial-grade proxies like Nginx and
   HAProxy. Each implementation MUST support the security requirements
   specified by S2CS.

   S2DS MAY authenticate all connections according to the security
   policies established by S2CS. For external connections (between
   facilities), S2DS SHOULD use TLS + PSK authentication. For internal
   connections, S2DS MAY use ingress-filtering
   based on authorized IP addresses.

3.1.4. Application Controllers

   Application controllers may or may not interface directly with the applications.
   They perform the following functions:

   - Send Hello messages to S2CS with connection details
   - Receive connection information from S2CS
   - Configure applications for data streaming (OPTIONAL)
   - Monitor streaming status (OPTIONAL)
   - Implement security protocols for application authentication (OPTIONAL)

   Application controllers MUST authenticate with S2CS using UID AND OAUTH2.0.
   They are responsible for configuring the applications to use the appropriate
   security settings for data streams.

   Application controllers MAY be integrated directly into ProdApp and
   ConsApp, or MAY be implemented as separate components that communicate
   with the applications via local interfaces.

3.2. Protocol Flow

   The SciStream protocol follows a defined sequence of operations to establish,
   maintain, and terminate data streaming sessions as illustrated in Figure 4:. This section describes the
   typical protocol flow for a streaming session.

   S2UC            Producer S2CS      Consumer S2CS      Apps
    |                   |                  |               |
    |---REQUEST(UID)--->|                  |               |
    |<----RESPONSE------|                  |               |
    |                   |<----HELLO--------|<--HELLO-------|
    |                   |----APPRESPONSE-->|---APPRESPONSE>|
    |--UPDATETARGETS--->|                  |               |
    |--UPDATETARGETS------------------>--->|               |
    |                   |<-----TUNNEL----->|               |
    |<----RESPONSE------|                  |               |
    |<----RESPONSE-------------------------|               |
    |                   |<======DATA STREAMING============>|
    |----RELEASE------->|                  |               |
    |----RELEASE---------------------->--->|               |
    |<----RESPONSE------|                  |               |
    |<----RESPONSE-------------------------|               |

            Figure 4: Protocol Sequence Diagram

3.2.1. Request Submission

   The S2UC initiates with REQUEST message to the S2CS. This message MUST include:

   1. A unique identifier (UID) for the session
   2. The role of the requester (PROD or CONS)
   3. The number of connections requested

3.2.2. Hello Message Exchange

   After the request is approved, the application controllers at both the
   producer and consumer sides send HELLO messages to their respective S2CS
   instances to register their connection details, independently.

   The HELLO message includes:

   1. The session UID matching the initial request
   2. For producers: the list of listener endpoints
   3. The role (PROD or CONS)

3.2.3. Tunnel Setup

   After the HELLO messages are processed, the S2UC sends an UPDATETARGETS
   message to each S2CS to provide information about the remote endpoints
   for connection establishment.

   The UPDATETARGETS message includes:

   1. The session UID
   2. The list of remote listener endpoints
   3. The role (PROD or CONS)

3.2.4. Data Streaming

   Once the tunnel is established, data streaming begins. The data flows
   through the S2DS instances, which handle the security and forwarding of
   the streams.

   During data streaming:

   1. Producer applications generate data and send it to their local S2DS
   2. Producer S2DS forwards the data to the consumer S2DS over secure channels
   3. Consumer S2DS delivers the data to consumer applications
   // 4. S2DS instances monitor and manage the streaming connections
   // 5. S2CS instances maintain session state and enforce policies

   The streaming continues until either side terminates the connection or
   the session is explicitly released.

3.2.5. Request Release

   When a streaming session is no longer needed, the S2UC sends a RELEASE
   message to both S2CS instances to terminate the session and release
   allocated resources.

   The RELEASE message includes:

   1. The session UID to be released

4. Protocol Messages

   SciStream uses Protocol Buffers for message definition
   and gRPC for service communication. This section details the message
   formats and service definitions.

4.1. Message Definitions

   The SciStream protocol defines the following message types:

   - REQUEST: Sent by S2UC to S2CS to authorize a streaming session
   - HELLO: Sent by application controllers to S2CS to register endpoints
   - UPDATETARGETS: Sent by S2UC to S2CS to update connection targets
   - RELEASE: Sent to S2CS to terminate a streaming session and release resources
   - RESPONSE: Sent by S2CS in response to REQUEST and UPDATETARGETS commands
   - APPRESPONSE: Sent by S2CS in response to HELLO commands

4.2. Service Definition

   The SciStream protocol defines a gRPC service for control channel communication.
   This service exposes RPC methods for all major protocol operations.

4.3. Protocol Buffer Schema

   The complete Protocol Buffer schema for SciStream messages is provided
   below:

   ```protobuf
   syntax = "proto3";

   package scistream;

   // SciStream Control Service
   service SciStreamControl {
       // Request a new streaming session
       rpc RequestStream(Request) returns (Response);

       // Update connection targets
       rpc UpdateTargets(UpdateTargets) returns (Response);

       // Register application endpoints
       rpc Hello(Hello) returns (AppResponse);

       // Release a streaming session
       rpc ReleaseStream(Release) returns (Response);
   }

   // Request message for initiating a streaming session
   message Request {
       string uid = 1;     // Unique identifier for the request
       string role = 2;    // Role (PROD or CONS)
       int32 num_conn = 3; // Number of connections requested
       int32 rate = 4;     // Requested data rate (NOT_IMPLEMENTED)
   }

   // Response message from S2CS
   message Response {
       repeated string listeners = 1;     // Available listener endpoints
       repeated string prod_listeners = 2; // Producer listener endpoints
   }

   // Hello message for registering application endpoints
   message Hello {
       string uid = 1;                     // Request identifier
       repeated string prod_listeners = 2; // Producer listener endpoints
       string role = 3;                    // Role in the TLS authentication
   }

   // AppResponse message from S2CS
   message AppResponse {
       string message = 1;           // Status message
       repeated string listeners = 2; // Available listener endpoints
   }

   // UpdateTargets message for providing connection information
   message UpdateTargets {
       string uid = 1;                       // Request identifier
       repeated string remote_listeners = 2; // Remote endpoints to connect to
       string role = 3;                      // Role (PROD or CONS)
   }

   // Release message for terminating a streaming session
   message Release {
       string uid = 1; // Request identifier to release
   }
   ```

   This schema defines all message types and the service interface for
   the SciStream protocol.

5. Security Framework

   SciStream's security framework is designed around a zero-trust architecture
   that provides comprehensive protection for both control and data channels.
   This section describes the security model, authentication mechanisms, and
   protection features.

5.1. Security Model

   SciStream provides an abstract mechanism for authentication and authorization of
   data streams, inbound and outbound from a security domain. The security
   model is based on the following principles:

   1. Zero-trust architecture: No component or entity is implicitly trusted
   2. Defense in depth: Multiple security layers protect critical assets
   3. Explicit verification: All accesses require explicit verification

   The security model addresses several threat vectors:

   - Unauthorized access to control services
   - Eavesdropping and tampering on control messages
   - Eavesdropping and tampering on data streams
   - Replay attacks
   - Cross-domain security policy violations

   Figure 5 illustrates the security layers in the SciStream protocol:

   +----------------------+
   | Application Layer    |
   | (Optional TLS+PSK)  |
   +----------------------+
              |
   +----------------------+
   | Data Channel Layer   |
   | (TLS+PSK)            |
   +----------------------+
              |
   +----------------------+
   | Control Channel Layer|
   | (OAUTH2.0 + TLS)     |
   +----------------------+

        Figure 5: SciStream Security Layers

5.2. Authentication Mechanisms

   SciStream employs different authentication mechanisms for the control
   channel and data channel to provide comprehensive security.

5.2.1. Control Channel Authentication

   Authentication between SciStream Client and SciStream Control Server is based
   on OAUTH2.0 access tokens. This allows for delegation of authority but can
   also be considered an external dependency. Failure could cause unavailability.
   SciStream client identities can be verified via OAUTH2.0 and federated
   identity management is supported. The reference implementation leverages Globus Auth.

   Control channel security is implemented via TLS. SciStream server digital
   certificates can be verified by the SciStream clients.

   The OAUTH2.0 process works the following way:

   1. User requests OAUTH2.0 token, this token represents identity and authorized permissions(scopes)
   2. SciStream client securely stores this token and includes it in the authorization header
      of all SciStream requests sent to a SciStream Control Server
   3. SciStream Control server validates tokens with Globus Auth before processing a request

   Implementations MUST use TLS 1.2 or higher for all control channel
   communications. Self-signed certificates MAY be used in development
   environments but SHOULD NOT be used in production deployments.

5.2.2. Data Channel Authentication

   Authentication between SciStream Data Servers is based on a shared secret, the UID.
   This is used as a Pre-Shared Key (PSK) for the TLS tunnel establishment.
   This is a simple yet effective mechanism for mutual authentication.

   Authentication between Data Applications and SciStream Data servers is OPTIONAL.
   This also relies on the UID as a shared secret for the TLS tunnel establishment.

   The data channel authentication process works as follows:

   1. S2UC generates a unique UID for each request.
   2. The user provides this UID to both producer and consumer application
      controllers.
   3. Application controllers include the UID in their Hello messages
      to S2CS.
   4. S2CS validates the UID against its record of active requests.
   5. If the UID is valid, S2CS accepts the Hello message and proceeds
      with the connection setup. If not, S2CS returns an authentication
      error.

   Authentication between S2DS instances is based on PSK-TLS
   authentication. This provides strong authentication for the data transport layer.

   The UID MUST be generated using a cryptographically secure random number
   generator and SHOULD be at least 128 bits of entropy, typically represented
   as a 32-character hexadecimal string.

5.3. Protection Mechanisms

   SciStream provides mechanisms for protecting both control messages
   and data streams against eavesdropping and tampering.

5.3.1. Data Integrity Protection

   Data integrity protection ensures that messages and data streams are
   not altered in transit. SciStream provides the following integrity
   protection mechanisms:

   1. Control Channel Integrity: gRPC over TLS provides integrity
      protection for all control messages between S2UC and S2CS.

   2. Data Channel Integrity: S2DS implementations MAY provide configurable
      integrity protection for data streams. We suggest TLS-based protection.

5.4. Cross-Domain Security

   Cross-domain security is a critical aspect of SciStream, as it is designed
   to facilitate data streaming between separate security domains (facilities).
   SciStream addresses cross-domain security through:

   1. Explicit authorization of all cross-domain connections
   2. Isolation of control and data planes
   3. Independent security policies at each facility
   4. Secure authentication for all cross-domain communications
   5. End-to-end encryption of sensitive data

   Each facility MAY implement additional security measures such as ingress filtering
   based on its specific requirements and policies. These measures SHOULD be documented
   and communicated to users of the facility.

   Administrators of SciStream deployments SHOULD conduct regular security
   reviews and audits to ensure that cross-domain security requirements
   are being met.

6. Performance Considerations

   SciStream is designed to support high-performance data streaming between
   scientific facilities. This section discusses key performance considerations
   for SciStream implementations.

6.1. Parallel Streaming Channels

   To maximize throughput, SciStream supports parallel data channels
   between facilities. The number of parallel channels can be specified
   in the REQUEST message.

   Parallel channels can improve performance by:

   1. Utilizing multiple CPU cores for data processing
   2. Mitigating the impact of TCP slow-start on high-bandwidth links
   3. Providing better resilience against individual channel failures
   4. Improving load distribution across network paths

   SciStream implementations SHOULD provide guidance on selecting
   appropriate parallelism levels for different scenarios.

7. Implementation Considerations

7.1. Implementation Flexibility

   The SciStream protocol is designed to be relatively easy to implement
   because it relies on standard, widely-used components:

   - gRPC for control channel communication
   - OAUTH2.0 for authentication
   - TLS for secure communications

   Any component can be created to replace our reference implementation,
   with the understanding that there is currently no strict API between
   S2CS and S2DS defined in this specification. This intentional flexibility
   allows for diverse implementations tailored to specific environments.

   For example, SciStream components could be implemented in various ways:

   - S2CS API integrated directly into a firewall
   - S2DS deployed on dedicated Data Transfer Nodes (DTNs)
   - Application controllers tightly integrated with streaming libraries
   - Complete implementation within container orchestration platforms
   - Integration with HPC job submission systems

   This architectural flexibility enables SciStream to adapt to the unique
   requirements of different scientific facilities while maintaining
   protocol compatibility.

7.2. Extensibility

   SciStream is designed with extensibility as a core principle, allowing
   the protocol to evolve to meet emerging requirements. Key extensibility
   features include:

   -  Protocol Buffer Extensibility: Using Protocol Buffers allows for
      backward-compatible extensions by adding new fields to existing messages.
   -  Component Independence: The separation of S2UC, S2CS, and S2DS
      allows individual components to be upgraded or replaced independently.
   -  Authentication Mechanism Flexibility: While the reference implementation
      uses OAUTH2.0 with Globus Auth, other mechanisms can be supported.
   -  Data Channel Protocol Extensions: The underlying data transmission
      protocols can be extended or replaced to accommodate new performance
      requirements or security features.

   Future standardization efforts MAY focus on defining a formal API between
   S2CS and S2DS components to further enhance interoperability between
   different implementations.

7.3. Interoperability

7.3.1. Streaming Library Compatibility

   SciStream is designed to be agnostic to the specific streaming libraries
   used by applications. Implementations should consider:

   - Transport-layer transparency to support any protocol over TCP or UDP
   - Support for common streaming libraries (ZeroMQ, RabbitMQ, PVApy, etc.)
   - Minimal interference with application-level protocols
   - Testing with a variety of streaming libraries to ensure compatibility
   - Documentation of any known compatibility issues

   This approach minimizes the modifications required to existing
   scientific applications while enabling integration with modern
   infrastructure components.

   End-to-end data channel security can be implemented if the streaming library
   supports PSK-based TLS connections.

8. Error Codes and Status Messages

   This section defines the standard error codes and status messages used
   in SciStream. Consistent error reporting is essential for troubleshooting
   and interoperability.

   Table 1 lists the standard error codes and their descriptions:

   | Error Code      | Description                                        |
   |-----------------|----------------------------------------------------|
   | SUCCESS         | Operation completed successfully                   |
   | AUTH_ERROR      | Authentication or authorization failure            |
   | INVALID_UID     | Invalid or unknown UID                             |
   | NO_RESOURCE     | Requested resources unavailable                    |
   | CONN_ERROR      | Connection establishment failure                   |
   | VERSION_ERR     | Protocol version mismatch or unsupported version   |
   | RATE_LIMIT      | Rate limit or quota exceeded                       |
   | BAD_FORMAT      | Invalid message format or content                  |
   | SERVER_ERR      | Internal server error                              |
   | TIMEOUT         | Operation timed out                                |
   | NOT_IMPLEMENTED | Requested feature not implemented                  |
   | UNAVAILABLE     | Service temporarily unavailable                    |

                     Table 1: Standard Error Codes

   Error responses SHOULD include both the error code and a human-readable
   message describing the error and, when appropriate, suggestions for
   resolution.

   Example error message formats:

   1. Authentication failure:
      ```
      {
        "error_code": "AUTH_ERROR",
        "message": "Authentication failed: Invalid token",
        "details": "The provided OAuth token has expired or is invalid"
      }
      ```

   2. Resource unavailability:
      ```
      {
        "error_code": "NO_RESOURCE",
        "message": "Requested resources unavailable",
        "details": "Insufficient bandwidth available for requested connections",
        "retry_after": 300
      }
      ```

   3. Connection failure:
      ```
      {
        "error_code": "CONN_ERROR",
        "message": "Failed to establish connection to remote endpoint",
        "details": "Connection timeout after 30 seconds",
        "endpoint": "192.168.1.10:8080"
      }
      ```

   Implementations SHOULD log detailed error information to facilitate
   troubleshooting, but SHOULD avoid exposing sensitive information in
   error messages returned to clients.

9. Security Considerations

    SciStream is designed with security as a primary consideration. However,
    implementers should be aware of the following security considerations:

    1. **Authentication Dependencies**: The reliance on OAUTH2.0 for authentication
       creates a dependency on external identity providers. Implementations
       should consider fallback mechanisms for scenarios where these providers
       are unavailable.

    2. **UID Generation and Distribution**: The security of the data channel
       depends on the secrecy of the UID. Implementations must ensure that
       UIDs are generated using cryptographically secure methods and
       distributed securely to all components.

    3. **Cross-Domain Trust**: While SciStream facilitates cross-domain
       communication, it does not establish trust between domains. Facilities
       must establish appropriate trust relationships and policies separately.

    4. **Side-Channel Attacks**: Implementations should consider potential
       side-channel attacks, such as timing attacks, and implement appropriate
       mitigations.

    5. **Denial of Service**: The protocol should be implemented with
       appropriate resource limits and rate limiting to prevent denial of
       service attacks.

    6. **Man-in-the-Middle Attacks**: Proper certificate validation is
       essential to prevent man-in-the-middle attacks on the control channel.

    7. **Configuration Security**: Secure configuration of all components
       is critical to the overall security of the system. Default configurations
       should prioritize security over convenience.

    8. **Security Updates**: Implementations should have a process for
       updating security-critical components when vulnerabilities are
       discovered.

    For comprehensive security, all SciStream deployments SHOULD undergo
    regular security audits and penetration testing.

10. References

10.1. Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

10.2. Informative References

   [RFC2228]  Horowitz, M. and S. Lunt, "FTP Security Extensions",
              RFC 2228, DOI 10.17487/RFC2228, October 1997,
              <https://www.rfc-editor.org/info/rfc2228>.

   [RFC6887]  Wing, D., Ed., Cheshire, S., Boucadair, M., Penno, R., and
              P. Selkirk, "Port Control Protocol (PCP)", RFC 6887,
              DOI 10.17487/RFC6887, April 2013,
              <https://www.rfc-editor.org/info/rfc6887>.

   [OAUTH2]   Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
              RFC 6749, DOI 10.17487/RFC6749, October 2012,
              <https://www.rfc-editor.org/info/rfc6749>.

   [TLS1.2]   Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <https://www.rfc-editor.org/info/rfc5246>.

   [GRPC]     gRPC Authors, "gRPC: A high performance, open source
              universal RPC framework", <https://grpc.io/>.

Appendix A. Protocol State Machines

   This appendix provides detailed state machine diagrams for the main
   components of the SciStream protocol.

   A.1. S2UC State Machine

   The S2UC follows the state machine illustrated in Figure A-1:

   +---------------+
   | Unauthenticated |
   +-------+-------+
           |
           | Authenticate with OAUTH2.0
           v
   +---------------+
   | Authenticated   |
   +-------+-------+
           |
           | Generate UID and submit REQUEST
           v
   +---------------+
   | Request Pending  |
   +-------+-------+
           |
           | Receive RESPONSE
           v
   +---------------+
   | Session Setup   |
   +-------+-------+
           |
           | Send UPDATETARGETS
           v
   +---------------+
   | Tunnel         |
   | Establishment  |
   +-------+-------+
           |
           | Receive RESPONSE (success)
           v
   +---------------+
   | Active         |
   | Streaming      |
   +-------+-------+
           |
           | Send RELEASE
           v
   +---------------+
   | Session        |
   | Released       |
   +---------------+

             Figure A-1: S2UC State Machine

   A.2. S2CS State Machine

   The S2CS follows the state machine illustrated in Figure A-2:

   +---------------+
   | Idle           |
   +-------+-------+
           |
           | Receive REQUEST
           v
   +---------------+
   | Authenticating |
   +-------+-------+
           |
           | Authentication result
           v
   +---------------+   Failure    +---------------+
   | Request       |------------->| Error         |
   | Processing    |              | Response      |
   +-------+-------+              +---------------+
           |
           | Success: Allocate resources and send RESPONSE
           v
   +---------------+
   | Session       |
   | Pending       |
   +-------+-------+
           |
           | Receive HELLO messages from applications
           v
   +---------------+
   | App           |
   | Registration  |
   +-------+-------+
           |
           | Receive UPDATETARGETS
           v
   +---------------+
   | Tunnel        |
   | Setup         |
   +-------+-------+
           |
           | Connection established, send RESPONSE
           v
   +---------------+
   | Active        |
   | Session       |
   +-------+-------+
           |
           | Receive RELEASE
           v
   +---------------+
   | Releasing      |
   | Resources     |
   +-------+-------+
           |
           | Resources released, send RESPONSE
           v
   +---------------+
   | Idle           |
   +---------------+

             Figure A-2: S2CS State Machine

Appendix B. Implementation Examples

   This appendix provides example code snippets from the SciStream reference
   implementation, demonstrating how standard components like gRPC, Protocol
   Buffers, and OAUTH2.0 authentication are used to implement the protocol.

   B.1. Creating and Sending a Request

   The following example from the reference implementation shows how to create
   and send a Request message using gRPC and Protocol Buffers:

   ```python
   # From s2uc.py
   @utils.authorize  # Decorator for handling OAUTH2.0 authentication
   def client_request(stub, uid, role, num_conn, rate, scope_id="", metadata=None):
       try:
           # Create the request message
           request = scistream_pb2.Request(
               uid=uid, role=role, num_conn=num_conn, rate=rate
           )
           # Send the request using gRPC
           response = stub.req(request, metadata=metadata)
           return response
       except grpc.RpcError as e:
           if e.code() == grpc.StatusCode.UNAUTHENTICATED:
               print(f"Please obtain new credentials: {e.details()}")
               sys.exit(1)
           else:
               print(f"Another GRPC error occurred: {e.details()}")
   ```

   B.2. Sending a Hello Message

   This example demonstrates sending a Hello message to register application endpoints:

   ```python
   # From s2uc.py
   @utils.authorize
   def hello_request(stub, uid, role, listeners, scope_id="", metadata=None):
       # Create Hello message with producer listeners
       hello_req = scistream_pb2.Hello(uid=uid, role=role)
       hello_req.prod_listeners.extend(listeners)
       try:
           # Send the Hello message using gRPC
           response = stub.hello(hello_req, metadata=metadata)
           print("Hello message sent successfully")
           return response
       except grpc.RpcError as e:
           if e.code() == grpc.StatusCode.UNAUTHENTICATED:
               print(f"Please obtain new credentials: {e.details()}")
               sys.exit(1)
           else:
               print(f"Error sending hello message: {e.details()}")
           return None
   ```

   B.3. Updating Connection Targets

   This example shows how to update remote connection targets:

   ```python
   # From s2uc.py
   @utils.authorize
   def update(stub, uid, remote_listeners, role="PROD", scope_id="", metadata=None):
       try:
           # Create UpdateTargets message
           update_request = scistream_pb2.UpdateTargets(
               uid=uid, remote_listeners=remote_listeners, role=role
           )
           # Send the update request
           stub.update(update_request, metadata=metadata)
       except Exception as e:
           print(f"Error during update: {e}")
   ```

   B.4. Authentication with OAUTH2.0

   This example shows how SciStream authenticates users with Globus Auth using OAUTH2.0:

   ```python
   # From s2uc.py (simplified login function)
   def login(scope):
       """Get globus credentials for the Scistream User Client."""
       auth_client = NativeAppAuthClient("4787c84e-9c55-4881-b941-cb6720cea11c")
       StreamScopes = ScopeBuilder(scope, known_url_scopes=["scistream"])

       # Start OAuth2.0 flow requesting scistream scope
       auth_client.oauth2_start_flow(
           requested_scopes=[StreamScopes.scistream], refresh_tokens=True
       )

       # Get the authorization URL for the user to authenticate
       auth_url = auth_client.oauth2_get_authorize_url(query_params={"prompt": "login"})
       print(f"Authentication URL: {auth_url}")

       # Get the authorization code from the user
       auth_code = input("Enter the resulting Authorization Code here: ").strip()

       # Exchange the code for tokens
       tokens = auth_client.oauth2_exchange_code_for_tokens(auth_code)

       # Store the tokens for future use
       utils.storage_adapter().store(tokens)
   ```

   B.5. Establishing a Secure gRPC Channel

   This example demonstrates how to create a secure gRPC channel for
   communication with the S2CS:

   ```python
   # From s2uc.py (simplified from inbound_request function)
   def create_secure_channel(s2cs, server_cert):
       # Read server certificate
       with open(server_cert, "rb") as f:
           trusted_certs = f.read()

       # Create credentials with the certificate
       credentials = grpc.ssl_channel_credentials(
           root_certificates=trusted_certs
       )

       # Create the secure channel and stub
       with grpc.secure_channel(s2cs, credentials) as channel:
           stub = scistream_pb2_grpc.ControlStub(channel)

           # Now use the stub to make RPC calls
           # Example: uid = str(uuid.uuid1())
           # Example: stub.req(scistream_pb2.Request(uid=uid, role="PROD"))
   ```

   These examples demonstrate the simplicity of implementing SciStream
   using standard components. The actual implementation can be extended
   or modified to suit specific deployment requirements while maintaining
   protocol compatibility.
